// Code generated by MockGen. DO NOT EDIT.
// Source: interface.go
//
// Generated by this command:
//
//	mockgen -destination=producer_mock.go -package=kafkaproducer -source interface.go
//

// Package kafkaproducer is a generated GoMock package.
package kafkaproducer

import (
	context "context"
	reflect "reflect"
	time "time"

	sarama "github.com/IBM/sarama"
	gomock "go.uber.org/mock/gomock"
)

// MockIAsyncProducer is a mock of IAsyncProducer interface.
type MockIAsyncProducer struct {
	ctrl     *gomock.Controller
	recorder *MockIAsyncProducerMockRecorder
}

// MockIAsyncProducerMockRecorder is the mock recorder for MockIAsyncProducer.
type MockIAsyncProducerMockRecorder struct {
	mock *MockIAsyncProducer
}

// NewMockIAsyncProducer creates a new mock instance.
func NewMockIAsyncProducer(ctrl *gomock.Controller) *MockIAsyncProducer {
	mock := &MockIAsyncProducer{ctrl: ctrl}
	mock.recorder = &MockIAsyncProducerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIAsyncProducer) EXPECT() *MockIAsyncProducerMockRecorder {
	return m.recorder
}

// SendMessage mocks base method.
func (m *MockIAsyncProducer) SendMessage(ctx context.Context, msg *sarama.ProducerMessage) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SendMessage", ctx, msg)
}

// SendMessage indicates an expected call of SendMessage.
func (mr *MockIAsyncProducerMockRecorder) SendMessage(ctx, msg any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendMessage", reflect.TypeOf((*MockIAsyncProducer)(nil).SendMessage), ctx, msg)
}

// SendMessages mocks base method.
func (m *MockIAsyncProducer) SendMessages(ctx context.Context, msgs []*sarama.ProducerMessage) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SendMessages", ctx, msgs)
}

// SendMessages indicates an expected call of SendMessages.
func (mr *MockIAsyncProducerMockRecorder) SendMessages(ctx, msgs any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendMessages", reflect.TypeOf((*MockIAsyncProducer)(nil).SendMessages), ctx, msgs)
}

// MockISyncProducer is a mock of ISyncProducer interface.
type MockISyncProducer struct {
	ctrl     *gomock.Controller
	recorder *MockISyncProducerMockRecorder
}

// MockISyncProducerMockRecorder is the mock recorder for MockISyncProducer.
type MockISyncProducerMockRecorder struct {
	mock *MockISyncProducer
}

// NewMockISyncProducer creates a new mock instance.
func NewMockISyncProducer(ctrl *gomock.Controller) *MockISyncProducer {
	mock := &MockISyncProducer{ctrl: ctrl}
	mock.recorder = &MockISyncProducerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockISyncProducer) EXPECT() *MockISyncProducerMockRecorder {
	return m.recorder
}

// SendMessage mocks base method.
func (m *MockISyncProducer) SendMessage(ctx context.Context, msg *sarama.ProducerMessage) (int32, int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SendMessage", ctx, msg)
	ret0, _ := ret[0].(int32)
	ret1, _ := ret[1].(int64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// SendMessage indicates an expected call of SendMessage.
func (mr *MockISyncProducerMockRecorder) SendMessage(ctx, msg any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendMessage", reflect.TypeOf((*MockISyncProducer)(nil).SendMessage), ctx, msg)
}

// SendMessages mocks base method.
func (m *MockISyncProducer) SendMessages(ctx context.Context, msgs []*sarama.ProducerMessage) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SendMessages", ctx, msgs)
	ret0, _ := ret[0].(error)
	return ret0
}

// SendMessages indicates an expected call of SendMessages.
func (mr *MockISyncProducerMockRecorder) SendMessages(ctx, msgs any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendMessages", reflect.TypeOf((*MockISyncProducer)(nil).SendMessages), ctx, msgs)
}

// MockITelemetry is a mock of ITelemetry interface.
type MockITelemetry struct {
	ctrl     *gomock.Controller
	recorder *MockITelemetryMockRecorder
}

// MockITelemetryMockRecorder is the mock recorder for MockITelemetry.
type MockITelemetryMockRecorder struct {
	mock *MockITelemetry
}

// NewMockITelemetry creates a new mock instance.
func NewMockITelemetry(ctrl *gomock.Controller) *MockITelemetry {
	mock := &MockITelemetry{ctrl: ctrl}
	mock.recorder = &MockITelemetryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockITelemetry) EXPECT() *MockITelemetryMockRecorder {
	return m.recorder
}

// CollectWriteLatency mocks base method.
func (m *MockITelemetry) CollectWriteLatency(ctx context.Context, serviceName string, duration time.Duration, topic string, partition int32, typeName ProducerType, clientID string, success bool) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "CollectWriteLatency", ctx, serviceName, duration, topic, partition, typeName, clientID, success)
}

// CollectWriteLatency indicates an expected call of CollectWriteLatency.
func (mr *MockITelemetryMockRecorder) CollectWriteLatency(ctx, serviceName, duration, topic, partition, typeName, clientID, success any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CollectWriteLatency", reflect.TypeOf((*MockITelemetry)(nil).CollectWriteLatency), ctx, serviceName, duration, topic, partition, typeName, clientID, success)
}

// CollectWriteSize mocks base method.
func (m *MockITelemetry) CollectWriteSize(ctx context.Context, serviceName string, size int, topic string, partition int32, typeName ProducerType, clientID string, success bool) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "CollectWriteSize", ctx, serviceName, size, topic, partition, typeName, clientID, success)
}

// CollectWriteSize indicates an expected call of CollectWriteSize.
func (mr *MockITelemetryMockRecorder) CollectWriteSize(ctx, serviceName, size, topic, partition, typeName, clientID, success any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CollectWriteSize", reflect.TypeOf((*MockITelemetry)(nil).CollectWriteSize), ctx, serviceName, size, topic, partition, typeName, clientID, success)
}

// MockIErrorLogger is a mock of IErrorLogger interface.
type MockIErrorLogger struct {
	ctrl     *gomock.Controller
	recorder *MockIErrorLoggerMockRecorder
}

// MockIErrorLoggerMockRecorder is the mock recorder for MockIErrorLogger.
type MockIErrorLoggerMockRecorder struct {
	mock *MockIErrorLogger
}

// NewMockIErrorLogger creates a new mock instance.
func NewMockIErrorLogger(ctrl *gomock.Controller) *MockIErrorLogger {
	mock := &MockIErrorLogger{ctrl: ctrl}
	mock.recorder = &MockIErrorLoggerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIErrorLogger) EXPECT() *MockIErrorLoggerMockRecorder {
	return m.recorder
}

// LogError mocks base method.
func (m *MockIErrorLogger) LogError(ctx context.Context, err error) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "LogError", ctx, err)
}

// LogError indicates an expected call of LogError.
func (mr *MockIErrorLoggerMockRecorder) LogError(ctx, err any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LogError", reflect.TypeOf((*MockIErrorLogger)(nil).LogError), ctx, err)
}
